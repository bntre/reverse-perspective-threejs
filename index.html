<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Reverse Perspective Stereo Camera - three.js</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body { font-family: Monospace; background-color: #bfe3dd; margin: 0; overflow: hidden; }
			canvas { display: block; }
		</style>
	</head>

	<body>

		<div id="container"></div>

		<script type="importmap">
			{
				"imports": {
					"three":         "https://unpkg.com/three@0.160.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
				}
			}
		</script>

		<script type="module">

			const _threeJsUrl = 'https://rawcdn.githack.com/mrdoob/three.js/r160/';

			import * as THREE from 'three';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			//-------------------------------------------------------------------------
			class CustomPerspectiveStereoCamera extends THREE.PerspectiveCamera {
				constructor(width, height, perspective, zoom, focus, near, far) {
					// Call the parent constructor
					super(50, 1.0, near, far);
					this.setSize(width, height);
					this.zoom = zoom;
					this.focus = focus;
					this.perspective = perspective;
					this.stereoAngle = 0.05; // in radians, angle to rotate both projection matrices
				}

				setSize(width, height) {
					this.width = width; // single side size
					this.height = height;
					this.aspect = width / height; // and aspect
				}
				
				updateProjectionMatrix() {} // skip default update

				updateProjectionMatrixStereo(shift) { // shift is -1 (left) or 1 (right)

					const size = 1 / this.zoom; // use as height half-size
					const aspect = this.aspect;
					const p = this.perspective / size;

					let n = this.near - this.focus; // we put the camera to the focus plane (n is negative, f is positive)
					let f = this.far  - this.focus;

					// keep projection center out of clip range
					if (p > 0) {
						n = Math.max(n, -1 / p + 0.01);
					} else if (p < 0) {
						f = Math.min(f, -1 / p - 0.01);
					}

					const mP = new THREE.Matrix4();
					const me = mP.elements;
					me[0] = 1 / (size * aspect);
					me[5] = 1 / size;
					me[10] = (2 + p*(f+n))/(n-f);  // A   [-n,-f] -> [-1,1]
					me[14] = 1 + f*(p + me[10]);  // B
					me[11] = -p;
					me[15] = 1;

					// For more information about projection matrices: https://www.songho.ca/opengl/gl_projectionmatrix.html

					// rotate according to left or right eye
					const mR = new THREE.Matrix4();
					mR.makeRotationY(shift * this.stereoAngle);
					mP.multiply(mR);

					// put the camera to the focus plane
					const mT = new THREE.Matrix4();
					mT.makeTranslation(0, 0, this.focus);
					mP.multiply(mT);

					this.projectionMatrix.copy(mP);
					this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
				}
			}


			//-------------------------------------------------------------------------

			const container = document.getElementById( 'container' );

			const _renderer = new THREE.WebGLRenderer( { antialias: true } );
			_renderer.setPixelRatio( window.devicePixelRatio );
			_renderer.setScissorTest(true);
			_renderer.setAnimationLoop( animate );
			_renderer.setSize( window.innerWidth, window.innerHeight );
			container.appendChild( _renderer.domElement );

			const _camera = new CustomPerspectiveStereoCamera(
				window.innerWidth / 2,
				window.innerHeight,
				0.0,      // perspective
				0.2,      // zoom
				5,       // focus
				1, 9     // near / far
			);
			_camera.position.set( 0, 0, 5 );
			_camera.updateMatrixWorld();

			window.onresize = function () {
				_renderer.setSize( window.innerWidth, window.innerHeight );
				_camera.setSize( window.innerWidth / 2, window.innerHeight );
			};

			//-------------------------------------------------------------------------
			// Scene setup

			const _scene = new THREE.Scene();
			_scene.background = new THREE.Color( 0xbfe3dd );

			const pmremGenerator = new THREE.PMREMGenerator( _renderer );
			_scene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;

			if (1) { // Fog
				_scene.fog = new THREE.Fog( 0xbfe3dd, 4, 10 );
			}

			//-------------------------------------------------------------------------
			// Load models

			const _mixers = [];

			const loader = new GLTFLoader();

			const dracoLoader = new DRACOLoader();
			dracoLoader.setDecoderPath( _threeJsUrl + 'examples/jsm/libs/draco/gltf/' );
			loader.setDRACOLoader( dracoLoader );

			if (1) { // Tokyo
				loader.load( _threeJsUrl + 'examples/models/gltf/LittlestTokyo.glb', function ( gltf ) {

					const model = gltf.scene;
					model.position.set( 0.2, 1, -0.2 );
					model.scale.set( 0.01, 0.01, 0.01 );
					_scene.add( model );

					const mixer = new THREE.AnimationMixer( model );
					// duration 10 sec
					mixer.clipAction( gltf.animations[ 0 ] ).play();
					_mixers.push(mixer);

				}, undefined, function ( e ) {
					console.error( e );
				} );
			}

			if (1) { // Michelle
				loader.load( _threeJsUrl + 'examples/models/gltf/Michelle.glb', function ( gltf ) {
					const model = gltf.scene;
					model.position.set( -0.25, -0.95, 0.9 ); // under the poster
					model.scale.set( 0.3, 0.3, 0.3 );
					_scene.add( model );

					const mixer = new THREE.AnimationMixer( model );
					// duration 18.2333 sec, dance bpm 106.6 ?
					mixer.clipAction( gltf.animations[ 0 ] ).setEffectiveTimeScale( 72/106.6 ).play();
					_mixers.push(mixer);

				}, undefined, function ( e ) {
					console.error( e );
				} );
			}


			//-------------------------------------------------------------------------
			// Moving camera along a curve

			function makeCyclicInterpolant(sampleSize, data) {
				// data format (for sampleSize 3): [
				//		t0, v00, v01, v02,
				//		t1, v10, v11, v12,... ]

				const numSamples = data.length / (1 + sampleSize);
				
				// for smooth cycling just repeat the data into 3 partitions: [-1..0)[0..1)[1..2)
				const sampleTimes  = new Float32Array(3 * numSamples);
				const sampleValues = new Float32Array(3 * numSamples * sampleSize);

				for (let p = 0; p < 3; p++) { // partition (0,1,2)
					for (let i = 0; i < numSamples; i++) {
						const s = i * (1 + sampleSize); // sample source shift
						const t = p * numSamples + i; // sample target shift
						// times
						sampleTimes[t] = data[s + 0] + (p - 1.0);
						// values
						for (let j = 0; j < sampleSize; j++) {
							sampleValues[t * sampleSize + j] = data[s + 1 + j];
						}
					}
				}

				return new THREE.CubicInterpolant(sampleTimes, sampleValues, sampleSize);
			}

			let _cameraManualMode = true; // use Orbit controls instead of moving along the curve path

			let _cameraCurvePhase = 0.0; // [0..1)
			const _playCameraCurveSpeed = 2 / 33.15; // cycles per second

			const _cameraPositionCurve = new THREE.CatmullRomCurve3([
				new THREE.Vector3(-0.15, -0.75, 1.2), // O
				new THREE.Vector3(-0.2, -0.7, 2.0), // A
				new THREE.Vector3( 0.0, -0.1, 3.0), // B

				new THREE.Vector3(3.5, 4.0, 3.5), // C

				new THREE.Vector3(2.0, 0.0, -0.2), // B'
				new THREE.Vector3(0.8, -0.75, -0.2), // A'

				new THREE.Vector3(0.05, -0.75, 0.05), // O'
			], true, 'chordal');
			const _cameraTargetInterpolant = makeCyclicInterpolant(3, [
				0.0,	-0.25, -0.75, 0.9,
				0.15,	-0.25, -0.75, 0.9,
				0.45,	-0.25, -0.25, 0.9,
				0.5,	-0.25, -0.25, 0.9,
				0.75,	 0.5, 0.0, -0.5,
				0.9,	 0.0, -0.75, 0.0,
			]);
			const _cameraPerspectiveInterpolant = makeCyclicInterpolant(1, [
				0.0,	2.0,
				0.2,	-0.5,
				0.5,	-0.5,
				0.7,	0.7,
				0.8,	1.5,
			]);
			const _cameraZoomEInterpolant = makeCyclicInterpolant(1, [
				0.0,	0.9,
				0.4,	-1.0,
				0.45,	-1.5,
				0.7,	-1.0,
				0.8,	0.5,
			]);

			function updatePlanes(cameraTargetPos) {
				const focus = cameraTargetPos.clone().sub(_camera.position).length();
				_camera.focus = focus;
				_camera.near  = focus - 4;
				_camera.far   = focus + 4;
			}

			function updateCameraFromCurve() {
				const pos           = _cameraPositionCurve.getPointAt(_cameraCurvePhase);
				const target        = new THREE.Vector3(... _cameraTargetInterpolant.evaluate(_cameraCurvePhase));
				const perspective   = _cameraPerspectiveInterpolant.evaluate(_cameraCurvePhase)[0];
				const zoomE         = _cameraZoomEInterpolant.evaluate(_cameraCurvePhase)[0];

				// Position
				_camera.position.copy(pos);
				_camera.lookAt(target);
				//_camera.updateMatrixWorld(); // updated in lookAt
				
				// Projection
				updatePlanes(target);
				_camera.perspective = perspective;
				_camera.zoom = Math.pow(2.0, zoomE);
			}

			//-------------------------------------------------------------------------
			// Orbit controls (for manual camera mode)
			let _orbitControls;
			_orbitControls = new OrbitControls( _camera, _renderer.domElement );
			_orbitControls.target.set( 0, 0.5, 0 );
			_orbitControls.enableDamping = true;
			_orbitControls.enableZoom = false; // don't change camera distance
			_orbitControls.enablePan = false;
			_orbitControls.enableRotate = _cameraManualMode;
			_orbitControls.update();
			updatePlanes(_orbitControls.target);

			//-------------------------------------------------------------------------
			// Mouse/keyboard/touch control

			let _prevMouseX = 0, _prevMouseY = 0;
			let _mouseIsPressed = false; // used to stop playing on dragging
			let _prevTouchDistances = []; // distances between 2 touches [horz, vert]

			const canvas = _renderer.domElement;
			canvas.addEventListener('mousedown', (e) => {
				if (e.buttons) {
					_prevMouseX = e.clientX;
					_prevMouseY = e.clientY;
					_mouseIsPressed = true;
				}
			});
			document.addEventListener('mouseup', (e) => {
				_mouseIsPressed = false;
			});
			canvas.addEventListener('mousemove', (e) => {
				if (e.buttons) {
					const nX = e.clientX / window.innerWidth;
					const nY = e.clientY / window.innerHeight;
					const dX =  (e.clientX - _prevMouseX) / window.innerHeight; // "normalize"
					const dY = -(e.clientY - _prevMouseY) / window.innerHeight;
					_prevMouseX = e.clientX;
					_prevMouseY = e.clientY;
					if (e.buttons == 1) {
						if (e.ctrlKey) {
							if (_cameraManualMode) {
								_camera.zoom *= Math.pow(2, dX * 1.0);
							}
						}
						else if (e.shiftKey) {
							if (_cameraManualMode) {
								_camera.perspective += dX * 1.0;
							}
						}
						else {
							if (!_cameraManualMode) {
								_cameraCurvePhase += 1.0 - dX;
								_cameraCurvePhase %= 1.0;
								updateCameraFromCurve();
							}
						}
					}
				}
			}, { capture: true } );
			
			document.addEventListener('wheel', (e) => {
				e.preventDefault();
				if (e.ctrlKey) {
					if (_cameraManualMode) {
						_camera.zoom *= Math.pow(2, e.deltaY * 0.001);
					}
				} else if (e.altKey) {
					_camera.stereoAngle *= Math.pow(2, e.deltaY * 0.001);
				} else {
					if (_cameraManualMode) {
						_camera.perspective += e.deltaY * 0.001;
					}
				}
			}, { passive: false });
			
			document.addEventListener('keydown', (e) => {
				if (e.code == 'End') { // Stop the loop
					e.preventDefault();
					_renderer.setAnimationLoop( null );
				}
			});

			// Handle touches
			function getDistances(touch1, touch2) {
				const dx = touch2.clientX - touch1.clientX;
				const dy = touch2.clientY - touch1.clientY;
				return [Math.abs(dx), Math.abs(dy)];
			}
			canvas.addEventListener('touchstart', (e) => {
				if (e.touches.length === 2) {
					if (_cameraManualMode) {
						_prevTouchDistances = getDistances(...e.touches);
					}
				} else if (e.touches.length === 1) {
					if (!_cameraManualMode) {
						_prevMouseX = e.touches[0].clientX;
						_prevMouseY = e.touches[0].clientY;
						_mouseIsPressed = true;
					}
				}
			}, { passive: false });
			document.addEventListener('touchend', (e) => {
				if (e.touches.length === 0) {
					_mouseIsPressed = false;
				}
			});
			canvas.addEventListener('touchmove', e => {
				if (e.touches.length === 2) {
					if (_cameraManualMode) {
						e.preventDefault();
						const newDistances = getDistances(...e.touches);
						const dX = (newDistances[0] - _prevTouchDistances[0]) / window.innerHeight; // normalize
						const dY = (newDistances[1] - _prevTouchDistances[1]) / window.innerHeight; // normalize
						_camera.zoom *= Math.pow(2, dX * 3.0);
						_camera.perspective += dY * 3.0;
						_prevTouchDistances = newDistances;
					}
				} else if (e.touches.length === 1) {
					if (!_cameraManualMode) {
						const dX =  (e.touches[0].clientX - _prevMouseX) / window.innerHeight; // normalize
						const dY = -(e.touches[0].clientY - _prevMouseY) / window.innerHeight;
						_prevMouseX = e.touches[0].clientX;
						_prevMouseY = e.touches[0].clientY;
						// Update phase
						_cameraCurvePhase += 1.0 - dX;
						_cameraCurvePhase %= 1.0;
						updateCameraFromCurve();
					}
				}
			}, { passive: false });

			//-------------------------------------------------------------------------
			// GUI
			if (1) {
				const gui = new GUI();
				gui.close();
				const config = {
					manualCamera: _cameraManualMode, // true for active OrbitControls rotation
				};
				const manualControl = gui.add(config, 'manualCamera').name('Manual Camera');
				manualControl.onChange(value => {
					_cameraManualMode = !_cameraManualMode;
					_orbitControls.enableRotate = _cameraManualMode;
					if (_cameraManualMode) {
						// Switching to manual mode (orbit controls)
						_camera.position.multiplyScalar(5.0 / _camera.position.length());
						updatePlanes(_orbitControls.target);
					}
				});
				const desc = gui.addFolder('Description').close()
					.add({ info: '' }, 'info').domElement;
				desc.innerHTML =
`<pre>
Source: <a href="https://github.com/bntre/reverse-perspective-threejs" target="_blank" rel="noopener">GitHub</a>.
Models:
  <a href="https://www.mixamo.com/#/?query=Michelle&type=Character" target="_blank" rel="noopener">Michelle</a> by Mixamo,
  <a href="https://artstation.com/artwork/1AGwX" target="_blank" rel="noopener">Littlest Tokyo</a> by Glen Fox.

Automatic Camera:
  Mouse drag: move camera along the path

Manual Camera:
  Mouse drag: rotation
  L-button:
    + Shift: perspective
    + Ctrl: zoom
  Wheel: perspective
    + Ctrl: zoom
    + Alt: eye distance
  Horizontal pinch: zoom
  Vertical pinch: perspective

End: stop the program
</pre>`;
			}

			//-------------------------------------------------------------------------
			// Loop

			const _clock = new THREE.Clock();

			function animate() {

				const delta = _clock.getDelta();

				for ( const m of _mixers ) {
					m.update( delta );
				}

				if (_cameraManualMode) {
					_orbitControls.update();
				} else {
					if (!_mouseIsPressed) {
						_cameraCurvePhase += delta * _playCameraCurveSpeed;
						_cameraCurvePhase %= 1.0;
						updateCameraFromCurve();
					}
				}

				// Render both sides
				const w = _camera.width; // single side width
				const h = _camera.height;

				// Left side
				_camera.updateProjectionMatrixStereo(-1);
				_renderer.setViewport(0, 0, w, h);
				_renderer.setScissor (0, 0, w, h);
				_renderer.render(_scene, _camera);

				// Right side
				_camera.updateProjectionMatrixStereo(1);
				_renderer.setViewport(w, 0, w, h);
				_renderer.setScissor (w, 0, w, h);
				_renderer.render(_scene, _camera);
			}

		</script>
	</body>
</html>
